// Moat Chrome Extension - Content Script
(function() {
  let commentMode = false;
  let hoveredElement = null;
  let commentBox = null;
  let highlightedElement = null;
  let projectRoot = null;
  let fileHandle = null;
  let markdownFileHandle = null; // Handle for moat-tasks.md

  // Generate unique session ID
  const sessionId = `moat-session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Initialize when page loads
  function initializeQueue() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeQueue);
      return;
    }
    
    // Initialize queue if not exists
    if (!localStorage.getItem('moat.queue')) {
      localStorage.setItem('moat.queue', JSON.stringify([]));
    }
    
    // Show success message
    console.log('Moat: Extension loaded successfully');
    
    // Initialize project connection if available
    initializeProject();
  }

  // Initialize project connection
  async function initializeProject() {
    // Check if we have a saved project for this origin
    const savedProject = localStorage.getItem(`moat.project.${window.location.origin}`);
    if (savedProject) {
      const projectData = JSON.parse(savedProject);
      projectRoot = projectData.path;
      
      // Notify Moat of connection status
      window.dispatchEvent(new CustomEvent('moat:project-connected', { 
        detail: { path: projectRoot, status: 'connected' } 
      }));
    } else {
      // Notify Moat that no project is connected
      window.dispatchEvent(new CustomEvent('moat:project-connected', { 
        detail: { status: 'not-connected' } 
      }));
    }
  }

  // Set up project connection
  async function setupProject() {
    console.log('Moat: Starting project setup...');
    
    try {
      // Check if File System Access API is available
      if (!('showDirectoryPicker' in window)) {
        console.error('Moat: File System Access API not supported');
        showNotification('Your browser doesn\'t support file system access. Use Chrome 86+ or Edge 86+', 'error');
        return false;
      }
      
      console.log('Moat: File System Access API available, showing directory picker...');
      
      // Use File System Access API to let user choose project directory
      const dirHandle = await window.showDirectoryPicker({
        mode: 'readwrite',
        startIn: 'documents'
      });
      
      console.log('Moat: Directory selected:', dirHandle.name);
      projectRoot = dirHandle.name;
      
      // Create .moat directory
      const moatDir = await dirHandle.getDirectoryHandle('.moat', { create: true });
      
      // Store .moat directory handle for moat.js to access
      window.directoryHandle = moatDir;
      console.log('Moat: Stored directory handle for moat.js:', moatDir);
      
      // Create config file
      const configFile = await moatDir.getFileHandle('config.json', { create: true });
      const configWritable = await configFile.createWritable();
      await configWritable.write(JSON.stringify({
        version: '1.0.0',
        projectName: dirHandle.name,
        createdAt: new Date().toISOString(),
        streaming: {
          enabled: true,
          format: 'jsonl',
          cursorIntegration: true
        },
        ui: {
          autoShowMoat: true,
          confirmBeforeSend: false
        }
      }, null, 2));
      await configWritable.close();
      
      // Store file handle for stream file
      fileHandle = await moatDir.getFileHandle('.moat-stream.jsonl', { create: true });
      
              // Store file handle for markdown tasks file
        console.log('Moat: Creating markdown file handle...');
        markdownFileHandle = await moatDir.getFileHandle('moat-tasks.md', { create: true });
        console.log('Moat: Markdown file handle created successfully');
        
        // Initialize markdown file with header if empty
        try {
          console.log('Moat: Checking if markdown file needs initialization...');
          const markdownFile = await markdownFileHandle.getFile();
          const content = await markdownFile.text();
          console.log('Moat: Current markdown file content length:', content.length);
          
          if (!content.trim()) {
            console.log('Moat: Initializing empty markdown file...');
            const markdownWritable = await markdownFileHandle.createWritable();
            await markdownWritable.write(`# Moat Tasks

Generated by Moat Chrome Extension

`);
            await markdownWritable.close();
            console.log('Moat: Markdown file initialized');
          } else {
            console.log('Moat: Markdown file already has content');
          }
        } catch (e) {
          console.warn('Moat: Could not initialize markdown file', e);
        }
        
        // Also create/initialize summary file
        try {
          console.log('Moat: Creating summary file...');
          const summaryFileHandle = await moatDir.getFileHandle('moat-tasks-summary.md', { create: true });
          const summaryFile = await summaryFileHandle.getFile();
          const summaryContent = await summaryFile.text();
          
          if (!summaryContent.trim()) {
            console.log('Moat: Initializing summary file...');
            const summaryWritable = await summaryFileHandle.createWritable();
            await summaryWritable.write(`# Moat Tasks - Local Development

**Total**: 0 | **Pending**: 0 | **Completed**: 0

## Tasks

*No tasks yet - create annotations to populate this list*

## Quick Stats
- 🔥 **High Priority**: 0 tasks
- ⚡ **Medium Priority**: 0 tasks  
- 💡 **Low Priority**: 0 tasks

---
*Last updated: ${new Date().toLocaleString()}*
*Use @process-moat-tasks.mdc for implementation*
`);
            await summaryWritable.close();
            console.log('Moat: Summary file initialized');
          }
        } catch (e) {
          console.warn('Moat: Could not initialize summary file', e);
        }
      
      // Save project connection
      localStorage.setItem(`moat.project.${window.location.origin}`, JSON.stringify({
        path: dirHandle.name,
        connectedAt: Date.now()
      }));
      
      // Update .gitignore if it exists
      try {
        const gitignoreHandle = await dirHandle.getFileHandle('.gitignore', { create: false });
        const gitignoreFile = await gitignoreHandle.getFile();
        let gitignoreContent = await gitignoreFile.text();
        
        if (!gitignoreContent.includes('.moat-stream.jsonl')) {
          gitignoreContent += '\n# Moat annotations stream\n.moat-stream.jsonl\nmoat-tasks.md\n';
          const gitignoreWritable = await gitignoreHandle.createWritable();
          await gitignoreWritable.write(gitignoreContent);
          await gitignoreWritable.close();
        }
      } catch (e) {
        // .gitignore doesn't exist, that's okay
      }
      
      // Notify success
      window.dispatchEvent(new CustomEvent('moat:project-connected', { 
        detail: { path: dirHandle.name, status: 'connected' } 
      }));
      
      showNotification('✅ Moat connected to project!');
      
      // Re-save fileHandle reference for streaming
      await getStreamFileHandle(dirHandle);
      
      return true;
    } catch (error) {
      console.log('Moat: Project setup error details:', error.name, error.message);
      
      if (error.name === 'AbortError') {
        console.log('Moat: User cancelled directory picker');
        showNotification('Project connection cancelled');
      } else if (error.name === 'NotAllowedError') {
        console.error('Moat: Permission denied for file system access');
        showNotification('Permission denied. Please allow file system access.', 'error');
      } else if (error.name === 'SecurityError') {
        console.error('Moat: Security error accessing file system');
        showNotification('Security error. Make sure you\'re on localhost or HTTPS.', 'error');
      } else {
        console.error('Moat: Project setup failed', error);
        showNotification(`Failed to connect to project: ${error.message}`, 'error');
      }
      return false;
    }
  }

  // Get file handle for streaming
  async function getStreamFileHandle(dirHandle) {
    try {
      if (!dirHandle && localStorage.getItem(`moat.project.${window.location.origin}`)) {
        // Try to reconnect to saved project
        const projectData = JSON.parse(localStorage.getItem(`moat.project.${window.location.origin}`));
        // Note: We can't persist directory handles across sessions due to security
        // User will need to re-grant access
        return null;
      }
      
      const moatDir = await dirHandle.getDirectoryHandle('.moat', { create: true });
      fileHandle = await moatDir.getFileHandle('.moat-stream.jsonl', { create: true });
      
      // Also get markdown file handle
      markdownFileHandle = await moatDir.getFileHandle('moat-tasks.md', { create: true });
      
      return fileHandle;
    } catch (error) {
      console.error('Moat: Could not get file handles', error);
      return null;
    }
  }

  // Stream annotation to file
  async function streamAnnotation(annotation) {
    if (!fileHandle) {
      console.warn('Moat: No file handle available for streaming');
      return false;
    }
    
    try {
      // Read existing content
      const file = await fileHandle.getFile();
      const existingContent = await file.text();
      
      // Append new annotation as JSONL
      const annotationLine = JSON.stringify({
        timestamp: Date.now(),
        annotation: annotation,
        formatting: {
          cursorPrompt: `Fix this UI issue:\nElement: ${annotation.elementLabel}\nIssue: ${annotation.content}\nSelector: ${annotation.target}\nURL: ${annotation.pageUrl}`,
          targetFile: suggestTargetFile(annotation)
        }
      }) + '\n';
      
      // Write back with new line
      const writable = await fileHandle.createWritable();
      await writable.write(existingContent + annotationLine);
      await writable.close();
      
      // Update annotation status
      updateAnnotationStatus(annotation.id, 'sent');
      
      return true;
    } catch (error) {
      console.error('Moat: Failed to stream annotation', error);
      
      // If we lost permission, notify user
      if (error.name === 'NotAllowedError' || error.name === 'SecurityError') {
        fileHandle = null;
        localStorage.removeItem(`moat.project.${window.location.origin}`);
        window.dispatchEvent(new CustomEvent('moat:project-disconnected'));
        showNotification('Lost connection to project. Please reconnect.', 'error');
      }
      
      return false;
    }
  }

  // Suggest target file based on annotation
  function suggestTargetFile(annotation) {
    // This is a simple heuristic - could be made smarter
    const url = new URL(annotation.pageUrl);
    const path = url.pathname;
    
    if (path === '/' || path === '') {
      return 'src/pages/index.tsx';
    } else {
      // Convert URL path to likely file path
      const cleanPath = path.replace(/^\//, '').replace(/\/$/, '');
      return `src/pages/${cleanPath}.tsx`;
    }
  }

  // Update annotation status
  function updateAnnotationStatus(annotationId, status) {
    const queue = JSON.parse(localStorage.getItem('moat.queue') || '[]');
    const annotation = queue.find(a => a.id === annotationId);
    if (annotation) {
      annotation.status = status;
      localStorage.setItem('moat.queue', JSON.stringify(queue));
      window.dispatchEvent(new CustomEvent('moat:annotation-status-updated', { 
        detail: { id: annotationId, status } 
      }));
      
      // Update markdown file with new status
      if (markdownFileHandle) {
        updateMarkdownTaskStatus(annotation);
      }
    }
  }

  // Update task status in markdown file
  async function updateMarkdownTaskStatus(annotation) {
    if (!markdownFileHandle) return;
    
    try {
      const file = await markdownFileHandle.getFile();
      let content = await file.text();
      
      // Find the task entry by ID
      const taskIdPattern = new RegExp(`- \\*\\*ID:\\*\\* \`${annotation.id}\``, 'g');
      const match = taskIdPattern.exec(content);
      
      if (match) {
        // Find the status line before the ID
        const beforeId = content.substring(0, match.index);
        const statusLinePattern = /- \*\*Status:\*\* ([^\n]+)/g;
        let statusMatch;
        let lastStatusMatch = null;
        
        // Find the last status match before our ID
        while ((statusMatch = statusLinePattern.exec(beforeId)) !== null) {
          lastStatusMatch = statusMatch;
        }
        
        if (lastStatusMatch) {
          // Replace the status
          const oldStatus = lastStatusMatch[0];
          const newStatus = `- **Status:** ${annotation.status}`;
          content = content.replace(oldStatus, newStatus);
          
          // Also update the emoji in the header
          const taskHeaderPattern = new RegExp(`## [📋📤⏳✅] ${annotation.elementLabel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`);
          const newEmoji = getStatusEmoji(annotation.status);
          content = content.replace(taskHeaderPattern, `## ${newEmoji} ${annotation.elementLabel}`);
          
          // Write back the updated content
          const writable = await markdownFileHandle.createWritable();
          await writable.write(content);
          await writable.close();
        }
      }
    } catch (error) {
      console.error('Moat: Failed to update markdown task status', error);
    }
  }

  // Show notification
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `float-notification ${type === 'error' ? 'float-error' : ''}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.remove(), 3000);
  }

  // Enhanced task classification functions
  function classifyPriority(annotation) {
    const content = annotation.content.toLowerCase();
    
    // High priority keywords
    if (content.includes('broken') || content.includes('fix') || 
        content.includes('error') || content.includes('bug') ||
        content.includes('urgent') || content.includes('critical')) {
      return { level: 'High', emoji: '🔥' };
    }
    
    // Low priority keywords  
    if (content.includes('maybe') || content.includes('nice') ||
        content.includes('consider') || content.includes('polish') ||
        content.includes('minor') || content.includes('small')) {
      return { level: 'Low', emoji: '💡' };
    }
    
    // Default to medium priority
    return { level: 'Medium', emoji: '⚡' };
  }
  
  function determineTaskType(annotation) {
    const content = annotation.content.toLowerCase();
    const target = annotation.target.toLowerCase();
    
    if (content.includes('color') || content.includes('font') || 
        content.includes('style') || content.includes('theme')) {
      return 'Styling';
    }
    
    if (content.includes('move') || content.includes('position') || 
        content.includes('align') || content.includes('center') ||
        content.includes('layout') || content.includes('size')) {
      return 'Layout';
    }
    
    if (content.includes('text') || content.includes('content') ||
        content.includes('copy') || content.includes('wording')) {
      return 'Content';
    }
    
    if (content.includes('add') || content.includes('new') ||
        content.includes('feature') || content.includes('enhance')) {
      return 'Enhancement';
    }
    
    return 'Styling'; // Default
  }
  
  function estimateImplementationTime(annotation) {
    const content = annotation.content.toLowerCase();
    const type = determineTaskType(annotation);
    
    // Quick changes (1-5 minutes)
    if (content.includes('color') || content.includes('font-size') ||
        content.includes('margin') || content.includes('padding')) {
      return '2 minutes';
    }
    
    // Medium changes (5-15 minutes)
    if (type === 'Layout' || content.includes('responsive') ||
        content.includes('position')) {
      return '10 minutes';
    }
    
    // Complex changes (15+ minutes)
    if (type === 'Enhancement' || content.includes('new') ||
        content.includes('add') || content.includes('feature')) {
      return '20 minutes';
    }
    
    return '5 minutes'; // Default
  }
  
  function generateApproach(annotation) {
    const content = annotation.content.toLowerCase();
    const type = determineTaskType(annotation);
    
    if (content.includes('blue')) {
      return 'Update CSS color property to blue (#3B82F6) or add blue utility class';
    }
    
    if (content.includes('bigger') || content.includes('larger')) {
      return 'Increase font-size or scale using CSS transform';
    }
    
    if (content.includes('center')) {
      return 'Add CSS centering with margin: 0 auto or text-align: center';
    }
    
    if (content.includes('move')) {
      return 'Adjust positioning using CSS position, top, left properties';
    }
    
    // Generic approach based on type
    switch (type) {
      case 'Styling': return 'Update CSS properties or utility classes';
      case 'Layout': return 'Modify CSS layout properties (display, position, flex)';
      case 'Content': return 'Update HTML content or text';
      case 'Enhancement': return 'Add new elements or functionality';
      default: return 'Apply requested changes following project patterns';
    }
  }
  
  function identifyFilesToModify(annotation) {
    const url = new URL(annotation.pageUrl);
    const path = url.pathname;
    
    // Common file patterns
    if (path === '/' || path === '') {
      return ['styles.css', 'index.html'];
    }
    
    // Component-based patterns
    if (annotation.elementLabel.includes('Hero')) {
      return ['components/Hero.tsx', 'styles/hero.css'];
    }
    
    if (annotation.elementLabel.includes('Navigation')) {
      return ['components/Navigation.tsx', 'styles/nav.css'];
    }
    
    return ['styles.css']; // Default
  }
  
  function generateTaskId() {
    const timestamp = Date.now();
    const hash = Math.random().toString(36).substr(2, 9);
    return `moat-${timestamp}-${hash}`;
  }
  
  function detectDependencies(annotation, existingTasks = []) {
    // Simple dependency detection - tasks affecting same element
    const sameSelectorTasks = existingTasks.filter(task => 
      task.target === annotation.target && task.status === 'pending'
    );
    
    if (sameSelectorTasks.length > 0) {
      return sameSelectorTasks.map(task => task.id);
    }
    
    return [];
  }
  
  function parseExistingTasks(markdownContent) {
    // Simple parser to extract existing task information
    const taskPattern = /## [🔥⚡💡]?\s*[📋🔄✅❌]?\s*Task\s+(\d+):\s*(.+)/g;
    const tasks = [];
    let match;
    
    while ((match = taskPattern.exec(markdownContent)) !== null) {
      tasks.push({
        id: `task-${match[1]}`,
        number: parseInt(match[1]),
        title: match[2].trim(),
        status: 'pending' // Simplified status detection
      });
    }
    
    return tasks;
  }
  
  function interpretUserIntent(annotation) {
    const content = annotation.content.toLowerCase();
    
    if (content.includes('broken') || content.includes('fix')) {
      return 'Fix functionality or visual issue';
    }
    
    if (content.includes('better') || content.includes('improve')) {
      return 'Enhance user experience';
    }
    
    if (content.includes('like') || content.includes('want')) {
      return 'Implement user preference';
    }
    
    if (content.includes('should') || content.includes('need')) {
      return 'Address functional requirement';
    }
    
    return 'Apply visual/functional change as requested';
  }

  // Log annotation to both summary and detailed markdown files
  async function logToMarkdown(annotation) {
    console.log('Moat: logToMarkdown called for:', annotation.elementLabel);
    
    if (!markdownFileHandle) {
      console.warn('Moat: No markdown file handle available');
      return false;
    }
    
    // Log to both files
    const summarySuccess = await logToSummaryMarkdown(annotation);
    const detailSuccess = await logToDetailedMarkdown(annotation);
    
    return summarySuccess && detailSuccess;
  }
  
  // Log to human-readable summary file (moat-tasks.md)
  async function logToSummaryMarkdown(annotation) {
    console.log('Moat: Creating summary markdown entry...');
    
    try {
      // Read existing summary content
      const file = await markdownFileHandle.getFile();
      const existingContent = await file.text();
      
      // Parse existing tasks
      const existingTasks = parseExistingTasks(existingContent);
      const taskNumber = existingTasks.length + 1;
      const priority = classifyPriority(annotation);
      const estimatedTime = estimateImplementationTime(annotation);
      
      // Create simple summary entry
      const summaryEntry = `${taskNumber}. ${priority.emoji} **${annotation.elementLabel}** - "${annotation.content}" *(${estimatedTime})* - 📋 pending\n`;
      
      // Update file
      if (!existingContent.trim()) {
        // Create new summary file
        const newContent = `# Moat Tasks - Local Development

**Total**: 1 | **Pending**: 1 | **Completed**: 0

## Tasks

${summaryEntry}
---
*Last updated: ${new Date().toLocaleString()}*
`;
        const writable = await markdownFileHandle.createWritable();
        await writable.write(newContent);
        await writable.close();
      } else {
        // Update existing summary
        let updatedContent = existingContent;
        
        // Update counters
        const totalMatch = updatedContent.match(/\*\*Total\*\*: (\d+)/);
        const pendingMatch = updatedContent.match(/\*\*Pending\*\*: (\d+)/);
        
        if (totalMatch) {
          const newTotal = parseInt(totalMatch[1]) + 1;
          const newPending = parseInt(pendingMatch[1]) + 1;
          updatedContent = updatedContent.replace(/\*\*Total\*\*: \d+/, `**Total**: ${newTotal}`);
          updatedContent = updatedContent.replace(/\*\*Pending\*\*: \d+/, `**Pending**: ${newPending}`);
        }
        
        // Add new task entry
        const tasksEnd = updatedContent.indexOf('\n---');
        updatedContent = updatedContent.slice(0, tasksEnd) + '\n' + summaryEntry + updatedContent.slice(tasksEnd);
        
        // Update timestamp
        updatedContent = updatedContent.replace(/\*Last updated:.*\*/, `*Last updated: ${new Date().toLocaleString()}*`);
        
        const writable = await markdownFileHandle.createWritable();
        await writable.write(updatedContent);
        await writable.close();
      }
      
      console.log('Moat: Summary markdown updated successfully');
      return true;
    } catch (error) {
      console.error('Moat: Failed to update summary markdown', error);
      return false;
    }
  }
  
  // Log to detailed AI-processable file (moat-tasks-detail.md) 
  async function logToDetailedMarkdown(annotation) {
    console.log('Moat: Creating detailed markdown entry...');
    
    try {
      // For detailed file, we'll need a separate handle - for now use the same one
      // TODO: Create separate file handle for moat-tasks-detail.md
      console.log('Moat: Reading existing detailed content...');
      
      // Enhanced task analysis
      const priority = classifyPriority(annotation);
      const taskType = determineTaskType(annotation);
      const estimatedTime = estimateImplementationTime(annotation);
      const approach = generateApproach(annotation);
      const filesToModify = identifyFilesToModify(annotation);
      const taskId = generateTaskId();
      
      // Parse existing tasks for dependency detection
      const existingTasks = parseExistingTasks(''); // Empty for now since we don't have detailed content
      const dependencies = detectDependencies(annotation, existingTasks);
      
      // Format annotation as enhanced markdown entry  
      const date = new Date(annotation.timestamp).toLocaleString();
      const isoDate = new Date(annotation.timestamp).toISOString();
      
      const detailedEntry = `
## ${priority.emoji} 📋 Task ${String(existingTasks.length + 1).padStart(3, '0')}: ${annotation.elementLabel}

**Priority**: ${priority.level}
**Type**: ${taskType}
**Estimated Time**: ${estimatedTime}
**Assigned**: Auto

### Request
"${annotation.content}"

### Technical Details
- **Element**: \`${annotation.target}\`
- **Location**: ${filesToModify[0]} ${filesToModify.length > 1 ? `(+${filesToModify.length - 1} more)` : ''}
- **Component**: ${annotation.elementLabel.split(':')[0]}
- **Page**: ${annotation.pageUrl}

### Implementation Plan
- **Approach**: ${approach}
- **Files to Modify**: ${filesToModify.join(', ')}
- **Dependencies**: ${dependencies.length > 0 ? dependencies.join(', ') : 'None'}
- **Testing Notes**: Verify change works across different screen sizes

### Context
- **Screenshot**: ${annotation.screenshot ? '![Element Screenshot](data:image/png;base64,...)' : 'Not captured'}
- **Element Info**: ${JSON.stringify(annotation.elementContext, null, 2)}
- **User Intent**: ${interpretUserIntent(annotation)}

### Status Tracking
- **Created**: ${isoDate}
- **Status**: 📋 pending
- **Completed**: Not yet
- **Applied Changes**: Pending implementation
- **Verification**: Awaiting processing

### Metadata
- **ID**: \`${taskId}\`
- **Session**: ${annotation.sessionId}
- **Browser**: Chrome Extension
- **Viewport**: ${window.innerWidth}x${window.innerHeight}

---

`;
      
      console.log('Moat: Detailed entry created successfully');
      return true;
    } catch (error) {
      console.error('Moat: Failed to create detailed markdown', error);
      return false;
    }
  }

  // Get status emoji for markdown
  function getStatusEmoji(status) {
    switch (status) {
      case 'in queue': return '📋';
      case 'sent': return '📤';
      case 'in progress': return '⏳';
      case 'resolved': return '✅';
      default: return '📋';
    }
  }

  // Add annotation to queue
  function addToQueue(annotation) {
    const queue = JSON.parse(localStorage.getItem('moat.queue') || '[]');
    queue.push(annotation);
    localStorage.setItem('moat.queue', JSON.stringify(queue));
    
    // Dispatch event for Moat to update
    window.dispatchEvent(new CustomEvent('moat:annotation-added', { detail: annotation }));
    
    // Log to markdown file
    console.log('Moat: Checking markdown logging...', { 
      hasMarkdownHandle: !!markdownFileHandle,
      hasFileHandle: !!fileHandle,
      annotationId: annotation.id 
    });
    
    if (markdownFileHandle) {
      console.log('Moat: Logging to markdown...', annotation.elementLabel);
      logToMarkdown(annotation).then(success => {
        console.log('Moat: Markdown logging result:', success);
      }).catch(error => {
        console.error('Moat: Markdown logging failed:', error);
      });
    } else {
      console.warn('Moat: No markdown file handle - connect to project first with Cmd+Shift+P');
      showNotification('📝 Connect to project (Cmd+Shift+P) to enable markdown task logging', 'warning');
    }
    
    // Try file streaming
    if (fileHandle) {
      // Use file streaming if AG-UI not available
      streamAnnotation(annotation);
    } else {
      // Neither AG-UI nor file streaming available
      updateAnnotationStatus(annotation.id, 'queued');
      showNotification('Annotation saved to queue. Connect to a project to process.', 'warning');
    }
  }

  // Get user-friendly element label
  function getElementLabel(element) {
    const tagName = element.tagName.toLowerCase();
    
    // For links
    if (tagName === 'a') {
      const text = element.textContent.trim();
      return text ? `Link: ${text}` : 'Link';
    }
    
    // For buttons
    if (tagName === 'button' || element.type === 'button') {
      const text = element.textContent.trim();
      return text ? `Button: ${text}` : 'Button';
    }
    
    // For inputs
    if (tagName === 'input') {
      const type = element.type || 'text';
      const placeholder = element.placeholder;
      const label = element.getAttribute('aria-label') || placeholder;
      return label ? `Input (${type}): ${label}` : `Input (${type})`;
    }
    
    // For images
    if (tagName === 'img') {
      const alt = element.alt;
      return alt ? `Image: ${alt}` : 'Image';
    }
    
    // For divs and containers
    if (tagName === 'div' || tagName === 'section' || tagName === 'article' || tagName === 'main') {
      const role = element.getAttribute('role');
      const ariaLabel = element.getAttribute('aria-label');
      const id = element.id;
      
      if (role) return `Container (${role})`;
      if (ariaLabel) return `Container: ${ariaLabel}`;
      if (id) return `Container #${id}`;
      
      // Check for common class patterns
      const classes = element.className.split(' ').filter(c => c && !c.startsWith('moat-'));
      if (classes.includes('header')) return 'Header Container';
      if (classes.includes('footer')) return 'Footer Container';
      if (classes.includes('sidebar')) return 'Sidebar Container';
      if (classes.includes('nav') || classes.includes('navigation')) return 'Navigation Container';
      if (classes.includes('content') || classes.includes('main')) return 'Main Container';
      
      // If it has background color or image, label it as such
      const computedStyle = window.getComputedStyle(element);
      if (computedStyle.backgroundImage !== 'none') return 'Background Container';
      if (computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)' && 
          computedStyle.backgroundColor !== 'transparent') return 'Colored Container';
      
      return 'Container';
    }
    
    // For lists
    if (tagName === 'ul' || tagName === 'ol') {
      return 'List';
    }
    
    if (tagName === 'li') {
      const text = element.textContent.trim().substring(0, 20);
      return text ? `List Item: ${text}${text.length > 20 ? '...' : ''}` : 'List Item';
    }
    
    // For elements with aria-label
    const ariaLabel = element.getAttribute('aria-label');
    if (ariaLabel) {
      return `${tagName}: ${ariaLabel}`;
    }
    
    // For elements with text content
    const text = element.textContent.trim().substring(0, 30);
    if (text) {
      return `${tagName}: ${text}${text.length > 30 ? '...' : ''}`;
    }
    
    // Default - capitalize tag name
    return tagName.charAt(0).toUpperCase() + tagName.slice(1);
  }

  // Get CSS selector for element
  function getSelector(element) {
    // First, check for ID
    if (element.id) {
      return `#${element.id}`;
    }
    
    const tagName = element.tagName.toLowerCase();
    
    // For links, try href attribute
    if (tagName === 'a' && element.href) {
      const href = element.getAttribute('href');
      if (href && href !== '#') {
        return `a[href="${href}"]`;
      }
    }
    
    // Check for unique attributes
    const uniqueAttributes = ['data-testid', 'data-id', 'data-component', 'aria-label', 'name', 'role'];
    for (const attr of uniqueAttributes) {
      const value = element.getAttribute(attr);
      if (value) {
        return `${tagName}[${attr}="${value}"]`;
      }
    }
    
    // For buttons/inputs with specific text
    if (tagName === 'button') {
      const text = element.textContent.trim();
      if (text && document.querySelectorAll(`button`).length > 1) {
        // Use nth-of-type to be more specific
        const parent = element.parentElement;
        const buttons = Array.from(parent.querySelectorAll('button'));
        const index = buttons.indexOf(element) + 1;
        if (index > 0) {
          return `${getSelector(parent)} > button:nth-of-type(${index})`;
        }
      }
    }
    
    // Build path-based selector
    const path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      // Skip if we hit an element with ID
      if (current.id) {
        path.unshift(`#${current.id}`);
        break;
      }
      
      // For containers, try to use semantic selectors
      if (selector === 'div' || selector === 'section' || selector === 'article') {
        const role = current.getAttribute('role');
        const dataTestId = current.getAttribute('data-testid');
        
        if (role) {
          selector = `${selector}[role="${role}"]`;
        } else if (dataTestId) {
          selector = `${selector}[data-testid="${dataTestId}"]`;
        } else {
          // Add classes (but filter out moat classes and common utility classes)
          if (current.className && typeof current.className === 'string') {
            const classes = current.className
              .split(' ')
              .filter(c => c && !c.startsWith('moat-') && !c.match(/^(w-|h-|p-|m-|flex|grid|block|inline)/))
              .slice(0, 2); // Only use first 2 meaningful classes
            
            if (classes.length > 0) {
              selector += `.${classes.join('.')}`;
            }
          }
        }
      } else {
        // For non-containers, add classes
        if (current.className && typeof current.className === 'string') {
          const classes = current.className
            .split(' ')
            .filter(c => c && !c.startsWith('moat-'))
            .slice(0, 2);
          
          if (classes.length > 0) {
            selector += `.${classes.join('.')}`;
          }
        }
      }
      
      // Add nth-child if needed
      if (current.parentElement) {
        const siblings = Array.from(current.parentElement.children);
        const index = siblings.indexOf(current) + 1;
        
        // Only add nth-child if there are multiple siblings of same type
        const sameTags = siblings.filter(s => s.tagName === current.tagName);
        if (sameTags.length > 1) {
          selector += `:nth-child(${index})`;
        }
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    // Return the path, limited to last 3 elements for brevity
    return path.slice(-3).join(' > ');
  }

  // Validate selector returns exactly one element
  function validateSelector(selector, targetElement) {
    try {
      const elements = document.querySelectorAll(selector);
      if (elements.length === 1 && elements[0] === targetElement) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  // Get enhanced element context
  function getElementContext(element) {
    return {
      tagName: element.tagName.toLowerCase(),
      text: element.textContent.trim().substring(0, 100),
      href: element.href || null,
      type: element.type || null,
      ariaLabel: element.getAttribute('aria-label') || null,
      dataTestId: element.getAttribute('data-testid') || null,
      className: element.className && typeof element.className === 'string' 
        ? element.className.split(' ').filter(c => c && !c.startsWith('moat-')).join(' ')
        : null
    };
  }

  // Create comment input box
  function createCommentBox(element, x, y) {
    // If comment box already exists, shake it instead of creating new one
    if (commentBox) {
      shakeCommentBox();
      return;
    }
    
    // Add visual confirmation pulse
    element.classList.add('float-highlight-pulse');
    setTimeout(() => {
      element.classList.remove('float-highlight-pulse');
    }, 500);
    
    commentBox = document.createElement('div');
    commentBox.className = 'float-comment-box';
    commentBox.innerHTML = `
      <textarea 
        class="float-comment-input" 
        placeholder="What needs to be fixed?"
        autofocus
      ></textarea>
      <div class="float-comment-actions">
        <button class="float-comment-cancel">Cancel</button>
        <button class="float-comment-submit">Submit (Enter)</button>
      </div>
    `;
    
    document.body.appendChild(commentBox);
    
    // Position near clicked element
    const rect = element.getBoundingClientRect();
    commentBox.style.left = `${Math.min(rect.left, window.innerWidth - 320)}px`;
    commentBox.style.top = `${rect.bottom + 10}px`;
    
    // Make sure it's visible in viewport
    const boxRect = commentBox.getBoundingClientRect();
    if (boxRect.bottom > window.innerHeight) {
      commentBox.style.top = `${rect.top - boxRect.height - 10}px`;
    }
    
    const textarea = commentBox.querySelector('textarea');
    const submitBtn = commentBox.querySelector('.float-comment-submit');
    const cancelBtn = commentBox.querySelector('.float-comment-cancel');
    
    // Focus textarea
    setTimeout(() => textarea.focus(), 50);
    
    // Handle submit
    const handleSubmit = async () => {
      const content = textarea.value.trim();
      if (!content) return;
      
      const rect = element.getBoundingClientRect();
      const selector = getSelector(element);
      
      // Validate selector
      if (!validateSelector(selector, element)) {
        console.warn('Moat: Selector validation failed, using fallback');
      }
      
      // Create annotation object
      const annotation = {
        type: "user_message",
        role: "user",
        content: content,
        target: selector,
        elementLabel: getElementLabel(element),
        elementContext: getElementContext(element),
        selectorMethod: "querySelector",
        boundingRect: {
          x: Math.round(rect.x),
          y: Math.round(rect.y),
          width: Math.round(rect.width),
          height: Math.round(rect.height)
        },
        pageUrl: window.location.href,
        timestamp: Date.now(),
        sessionId: sessionId,
        status: "in queue",
        id: `moat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      };
      
      // Try to capture screenshot
      if (window.html2canvas) {
        try {
          const canvas = await html2canvas(element, {
            backgroundColor: null,
            scale: 1,
            logging: false,
            width: rect.width,
            height: rect.height
          });
          annotation.screenshot = canvas.toDataURL('image/png');
        } catch (e) {
          console.warn('Moat: Screenshot capture failed', e);
        }
      }
      
      addToQueue(annotation);
      exitCommentMode();
    };
    
    // Event listeners
    submitBtn.addEventListener('click', handleSubmit);
    cancelBtn.addEventListener('click', exitCommentMode);
    
    textarea.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      } else if (e.key === 'Escape') {
        exitCommentMode();
      }
    });
  }

  // Shake comment box to indicate it's already open
  function shakeCommentBox() {
    if (!commentBox) return;
    
    commentBox.classList.add('float-shake');
    setTimeout(() => {
      commentBox.classList.remove('float-shake');
    }, 500);
    
    // Also focus the textarea
    const textarea = commentBox.querySelector('textarea');
    if (textarea) textarea.focus();
  }

  // Remove comment box
  function removeCommentBox() {
    if (commentBox) {
      commentBox.remove();
      commentBox = null;
    }
  }

  // Enter comment mode
  function enterCommentMode() {
    commentMode = true;
    document.body.classList.add('float-comment-mode');
    
    // Show notification
    const notification = document.createElement('div');
    notification.className = 'float-notification';
    notification.textContent = 'Click any element to annotate';
    document.body.appendChild(notification);
    
    setTimeout(() => notification.remove(), 3000);
  }

  // Exit comment mode
  function exitCommentMode() {
    commentMode = false;
    document.body.classList.remove('float-comment-mode');
    removeCommentBox();
    removeHighlight();
  }

  // Highlight element on hover
  function highlightElement(element) {
    removeHighlight();
    highlightedElement = element;
    element.classList.add('float-highlight');
  }

  // Remove highlight
  function removeHighlight() {
    if (highlightedElement) {
      highlightedElement.classList.remove('float-highlight');
      highlightedElement = null;
    }
  }

  // Export annotations
  function exportAnnotations() {
    const queue = JSON.parse(localStorage.getItem('moat.queue') || '[]');
    const exportData = {
      version: '1.0.0',
      sessionId,
      timestamp: Date.now(),
      url: window.location.href,
      protocol: 'file',
      annotations: queue
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `moat-annotations-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    showNotification(`Exported ${queue.length} annotations`);
  }

  // Mouse move handler
  document.addEventListener('mousemove', (e) => {
    if (!commentMode || commentBox) return; // Don't highlight if comment box is open
    
    const element = document.elementFromPoint(e.clientX, e.clientY);
    if (element && element !== hoveredElement && 
        !element.closest('.float-comment-box') && 
        !element.closest('.float-moat')) {
      hoveredElement = element;
      highlightElement(element);
    }
  });

  // Click handler
  document.addEventListener('click', (e) => {
    if (!commentMode) return;
    
    const element = e.target;
    if (element.closest('.float-comment-box') || element.closest('.float-moat')) {
      return;
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    createCommentBox(element, e.clientX, e.clientY);
  }, true);

  // Listen for keyboard events
  document.addEventListener('keydown', (e) => {
    // Enter comment mode with 'f' key
    if (e.key === 'f' && !commentMode && !e.target.matches('input, textarea')) {
      e.preventDefault();
      enterCommentMode();
    }
    
    // Exit comment mode with Escape
    if (e.key === 'Escape' && commentMode) {
      e.preventDefault();
      exitCommentMode();
    }
    
    // Toggle sidebar with Cmd+Shift+F
    if (e.key === 'f' && e.metaKey && e.shiftKey) {
      e.preventDefault();
      window.dispatchEvent(new CustomEvent('moat:toggle-moat'));
    }
    
    // Export annotations with Cmd+Shift+E
    if (e.key === 'e' && e.metaKey && e.shiftKey) {
      e.preventDefault();
      exportAnnotations();
    }
    
    // Connect to project with Cmd+Shift+P
    if (e.key === 'p' && e.metaKey && e.shiftKey) {
      e.preventDefault();
      setupProject();
    }
  });

  // Initialize Moat on page load
  initializeQueue();
  
  // Add Moat badge to indicate active status
  const badge = document.createElement('div');
  badge.className = 'float-badge';
  badge.innerHTML = `
    <div class="float-badge-content">
      <span class="float-badge-icon">🎯</span>
      <span class="float-badge-status">File</span>
    </div>
  `;
  document.body.appendChild(badge);

  console.log('Moat Chrome Extension loaded (AG-UI disabled)');

  // Listen for messages from popup
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'toggleMoat') {
      window.dispatchEvent(new CustomEvent('moat:toggle-moat'));
      sendResponse({ success: true });
    } else if (request.action === 'getQueueStatus') {
      const queue = JSON.parse(localStorage.getItem('moat.queue') || '[]');
      sendResponse({ 
        count: queue.length,
        protocol: 'file',
        projectConnected: !!fileHandle
      });
    } else if (request.action === 'exportAnnotations') {
      exportAnnotations();
      sendResponse({ success: true });
    }
    
    return true; // Keep message channel open for async response
  });

  // Listen for project setup requests from Moat
  window.addEventListener('moat:setup-project', (e) => {
    console.log('Moat: Received moat:setup-project event');
    setupProject();
  });
  
  // Listen for stream requests from Moat
  window.addEventListener('moat:stream-annotation', (e) => {
    if (e.detail && e.detail.annotation) {
      streamAnnotation(e.detail.annotation);
    }
  });
})(); 