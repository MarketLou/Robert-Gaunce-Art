---
description: 
globs: 
alwaysApply: true
---
# üìú Project Rules ‚Äî Float Chrome Extension

These are the implementation and integration rules for building and maintaining the Float Chrome Extension with a live annotation sidebar (‚ÄúMoat‚Äù) and Cursor feedback sync.

---

## üìò Project Purpose

Float is designed to let users visually annotate React/Next.js UIs running in `localhost`, structure those annotations as MCP-style events, and surface them in real time within a sidebar (Moat). These annotations are sent to Cursor for processing, where AI or developers can resolve them ‚Äî closing the feedback loop.

---

## üîß Architecture Rules

### üìÅ File Structure

- `content_script.js` ‚Äì handles element detection, comment trigger, and data capture
- `moat.js` ‚Äì renders the sidebar UI with real-time updates from localStorage
- `html2canvas.js` ‚Äì used for capturing screenshots of DOM elements
- `manifest.json` ‚Äì Chrome extension config (must match localhost scope)
- `float-core.js` (optional) ‚Äì shared utility functions (UUID, DOM selector, schema validation)

---

## üñº Annotation Handling
- All annotations must follow the defined MCP-compatible schema.
- Each annotation must include:
  - `target` (CSS selector)
  - `boundingRect` (for visual positioning)
  - `screenshot` (optional, auto-captured via html2canvas)
  - `status` field with values:
    - `"in queue"`
    - `"in progress"`
    - `"resolved"`

- Store queue in `localStorage` as `float.queue`

---

## üß† Moat Sidebar Rules

- Always visible when extension is toggled on
- Floats should appear in reverse chronological order
- Each float card should include:
  - DOM target label
  - Annotation content
  - Status indicator (dot color)
  - Timestamp
- Sidebar must:
  - Allow reordering of items
  - Update visual state as annotations progress
  - Allow filtering by status
  - Allow hover or click to highlight DOM element

---

## ‚öôÔ∏è Cursor Sync Protocol

- Use `.float.json` export OR local WebSocket to send annotations to Cursor
- Float must include `sessionId` and `timestamp` in all annotations
- Upon send:
  - Update `status` to `"in progress"`
- Cursor will return updated queue with `"resolved"` statuses

---

## üñ± Interaction Patterns

| Action                      | Effect                                 |
|-----------------------------|----------------------------------------|
| `c`                         | Enter comment mode                     |
| `Esc`                       | Exit comment mode                      |
| Click DOM element           | Triggers comment input overlay         |
| `Enter` in comment box      | Submits to queue, sends to Cursor      |
| `Cmd + Shift + F`           | Toggle Moat visibility                 |
| Click float in Moat         | Highlights corresponding DOM element   |
| Drag float in Moat          | Reorders priority                      |

---

## üí¨ AI Integration Guidelines

- Float output must use plain language (`content`) for each prompt
- Prompts must be actionable without backstory
- Use Cursor AI to transform prompts into:
  - CSS edits
  - JSX changes
  - Code suggestions or diffs
- Cursor can optionally respond into the queue with `"resolution"` data (planned)

---

## üí° Design Philosophy

Float is **UI feedback as structured data** ‚Äî lightweight, visible, and instant. The Moat is your command center for feedback. Cursor is the execution engine.

This setup should feel as responsive and transparent as live collaboration in Figma ‚Äî but wired directly into code.

---

# ü§ñ Float Automated Workflow Rules

You are an AI assistant that automatically processes Float UI annotations in real-time.

## Primary Directive
When asked to "process float annotations" or when viewing `.float/.float-stream.jsonl`, automatically:
1. Read the latest unprocessed annotations
2. Apply the requested fixes immediately
3. Show the changes made
4. Update the annotation status in your response

## Workflow Automation

### When Processing Annotations
1. **Read** the last line(s) of `.float/.float-stream.jsonl`
2. **Parse** the `formatting.cursorPrompt` for the issue
3. **Locate** the component using the `annotation.target` selector
4. **Apply** the fix based on the annotation content
5. **Confirm** the changes with a brief summary

### Annotation Structure
```json
{
  "annotation": {
    "content": "user's feedback",
    "target": "CSS selector",
    "elementLabel": "human-readable name",
    "elementContext": { /* element details */ }
  },
  "formatting": {
    "cursorPrompt": "pre-formatted AI prompt",
    "targetFile": "suggested file path"
  }
}
```

## Processing Rules

### Layout/Position Changes
- "move to bottom" ‚Üí Add `position: fixed; bottom: [value];` or Tailwind `fixed bottom-[value]`
- "center horizontally" ‚Üí Add `margin: 0 auto;` or Tailwind `mx-auto`
- "align right" ‚Üí Add `margin-left: auto;` or Tailwind `ml-auto`
- "16px spacing" ‚Üí Use `1rem` or Tailwind `4` (16px = 1rem = space-4)

### Style Changes
- Color requests ‚Üí Update background/text color classes
- Size changes ‚Üí Adjust width/height/padding
- Typography ‚Üí Update font size/weight/family

### Component Updates
- Text changes ‚Üí Update the component content directly
- Add elements ‚Üí Insert new JSX/HTML
- Remove elements ‚Üí Comment out or delete with explanation

## Automation Commands

### Command: "watch float"
Continuously monitor `.float/.float-stream.jsonl` and process new annotations automatically.

### Command: "process all float annotations"
Read and apply ALL unprocessed annotations in sequence.

### Command: "process latest float"
Apply only the most recent annotation.

## Implementation Pattern

When processing an annotation, follow this pattern:

1. **Identify the Component**
   - Use the file path hint from `formatting.targetFile`
   - Search for components matching the selector
   - Consider React component structure

2. **Apply the Change**
   ```tsx
   // Before
   <Link href="/profile">Profile</Link>
   
   // After (for "move to bottom, 16px above viewport")
   <Link href="/profile" className="fixed bottom-4 left-0">Profile</Link>
   ```

3. **Verify the Fix**
   - Ensure the change matches the request
   - Preserve existing functionality
   - Add comments if helpful

## Example Processing

For annotation: "Move this to the bottom, 16px above viewport"
- Target: `a[href='/profile']`
- Apply: Add positioning classes `fixed bottom-4`
- Confirm: "‚úì Moved Profile link to bottom with 16px spacing"

## Best Practices

1. **Preserve Functionality**: Never break existing features
2. **Use Semantic Classes**: Prefer Tailwind utilities when available
3. **Add Comments**: Mark Float-applied changes with `// Float: [description]`
4. **Incremental Changes**: Apply one annotation at a time
5. **Confirm Success**: Always summarize what was changed

## Auto-Response Format

When processing annotations, respond with:
```
üîÑ Processing Float Annotation
üìç Element: [elementLabel]
üéØ Change: [what was requested]
‚úÖ Applied: [what you did]
üìÅ File: [file modified]
```

## Continuous Mode

When in "watch float" mode:
- Check for new annotations every time you respond
- Process them automatically
- Keep a running log of changes
- Alert when no new annotations are found

Remember: The goal is to create a seamless feedback loop where UI annotations are instantly transformed into code changes without manual intervention.
